문제를 단순하게 모델링하자
FBA에서는 신뢰도가 높은 발리데이터가 다른 쿼럼슬라이스에 참여하는 횟수가 늘어나게 된다. 즉 FBA는 신뢰도에 따라 블록생성의 가중치를 부여받는 시스템이다.
그러므로, FBA에서 코인의 양에 따라 블럭생성에 대한 권리를 분배하는 것은 어려움이 있다. 
그러나, 쿼럼을 FBA특징을 담을 수 있는 최소한의 크기로 설정하고, 발리데이터가 가진 코인의 양만큼 쿼럼에 참여시키는 방법을 사용한다면, 그것을 구현하는 것이 보다 더 쉬워 질 것이다.

따라서 이것을 처리하는 유일한 방법은 코인의 양만큼 쿼럼에 참여시키는 방법일 것이다. 결국 이것은 쿼럼을 어떻게 다이나믹하게 유지하는냐가 관건이 된 것이다.

우리는 다뤄야 할 변수를 2개 가지고 있다. 그것은 다양한 유형의 쿼럼과, 다양한 코인의 양 이다. 이것을 해결하는 것은 어려울 수 있다. 그러나, 이 중 하나를 고정시킨다면 문제는 해결하기 쉽고, 그 결과를 설명하기도 쉽다. 
쿼럼의 조합은 무한하다. 노드가 추가될 수록 그 종류 또한 계속 늘어난다. 따라서 나는 이 방법으로 모든 경우에 대해 모든 사람이 납득할 수 있는 합리적인 방법을 제시하는 것이 어려울 수 있다고 생각한다. 그리고,  코인의 양은 인위적으로 고정시키기 불가능하다. 따라서 나는 쿼럼의 모양을 고정시키는 방법을 사용하는 것을 추천한다. 

그럼 새로운 방법은 무엇인가?
네트워크에는 다양한 코인의 갯수를 가진 발리데이터가 존재한다. 발리데이터가 가진 코인의 양만큼 합의에 참여할 수 있도록 하는 것이 핵심이다. 모든 발리데이터가 일제히 합의에 참여해야 한다는 고정관념을 버리고, 그들이 가지고 있는 코인의 양에 비례해서 합의에 참여할 수 있는 기회를 보장받는 시스템을 제안한다.

일정한 시점에 코인의 양을 어떻게 측정할 것인가?
일정한 시점에 함의에 참여할 기회를 어떻게 계산하는가?
먼저 2016개의 블록이 만들어 지는 기간을 1 사이클이라고 정의합니다.  2 사이클 이전의 특정 블록높이의 코인의 양으로 결정합니다.


쿼럼의 모델은 어떻게 되나?

쿼럼의 역활은 무엇인가?
우리는 단순한 하나의 쿼럼을 취급하지 않는다. FBA는 다 수 쿼럼슬라이스가 유기적으로 연결되어 있다. 하나의 쿼럼슬라이스의 결과가 다른 쿼럼슬라이스에 영향을 준다. 이러한 우리는 다 수의 쿼럼슬라이스의 발리데이터간의 상호견제와 보완에 의해 블록의 빠른 컴펌속도를 보장받을 수 있다.

블록을 만들기 위해

